#故障处理
> 此章节适合有初步使用zookeeper的经验及以上的用户

## 一个常见的场景
为实现一个独占锁的场景，客户端C1、C2需要创建并且抢先创建临时的节点，谁先创建先就抢到了锁。这里假设C1先抢到了锁，但是C1因为网络的原因与zookeeper断开了链接。这个场景是很有可能发生的，因为zookeeper在CAP三者中放弃了分区容灾性，通俗地说就是掩耳盗铃、埋头当鸵鸟。用官方的解释就是，这个工作他们交给了用户。
__什么情况下会出现这种情况？__
主要为2类
>一、著名的java fullgc，fullgc对于JAVA的世界就是静止，当大量的内存被不断地占用，可用的内存极其稀少，java会周期性地执行垃圾回收，以释放不再被使用的内存。但是不是每次的释放都那么迅速和有效，如果你的函数块创建了大量的内存，而且你又不去主动释放它(代码块没执行完，单靠JAVA是不能回收的，除非你使用了弱引用的技术，这里不单独介绍)。JAVA可能需要深度释放资源，这将需要大量的时间，这段时间所有的进程都是停止的，也包括和zookeeper的心跳进程。这就出现了假死的情况，客户端知道自己活着，zookeeper却认为客户端已经死了，将会删除节点，锁也就会被释放掉的。
>二、时钟偏移，客户端会定时与zookeeper进行心跳链接，如果因为机器负载过高，而造成客户端的心跳活动变慢或者延迟，这同样会导致这种情况。

## 如何处理故障
这和java的异常处理有异曲同工之处,无非就是该停止(重启)、额外处理、还是继续,也就是可恢复、不可恢复、群首选举。
#### 可恢复的故障
__Disconnected事件和ConnectionLossException__
从时机上，可分为用户请求时和监听时的处理
用户请求时将会捕捉到一个ConnectionLossException，并不代表你的操作失败的。比如你在执行一个create或者write动作，在执行下一个业务步骤时，务必检查一下你的操作是否成功了。
另外如果监听时发生的Disconnected事件呢？
这个需要特别注意群首的情况，在发生上述2类的假死状况，作为群首必须考虑另一端很有可能出现一个新的群首，成为脑裂现象，如果你的程序不予许两个群首（这样就变成不可恢复的故障了），那你务必得采取策略。__千万不要轻易做决定，需要小心应对这种情况__

#### 不可恢复的故障
对于不可恢复的故障，重启是一个很好的选择

#### 数据一致性
zookeeper是一个通过数据共享来实现群组选举的，避免脑裂对于资源的影响，可以通过__隔离__的技巧来实现。
具体的是，在创建群首的节点是，我们可以获取Stat结构的信息，该结构的成员之一czxid就是实现隔离技巧的工具，zxid是为唯一的且单调递增的序列号。在更新数据的时候提供这个隔离符号。zookeeper会选择留下最新zxid的请求而拒绝低版本的请求。

