#处理状态变化
> 这个章节适合中级的读者，讲述使用watch的过程中需要注意的问题(另关于watch等基础概念请参考其它的章节)。


关于状态的变化，遇到最棘手的场景是缓存的更新，除了PC的CPU、内存等一级、二级甚至三级缓存，我们渐渐有了应用程序级别的缓存以及独立式的缓存服务。比如enhecache、memcached、redis等等。每层的缓存都有其存在的价值，我们不能顾此失彼。比如及时有了独立式的缓存服务，我们还是少了应用程序级的缓存，原因是因为代价，独立式的服务器就像数据库一样，它会因为负载、网络等原因出现延迟等，而应用程序级的缓存却没有这个问题。
但是应用缓存的缺点在于数据的不一致，因为其获取和维护都依靠应用程序来实现，比如A程序更改了数据，但是其它的程序却不能感知这个变化然后去刷新这个数据。有人说可以靠主动的方式每次去轮循数据，确认数据是否有变化，你可以想象十几个节点时时去访问几十甚至几百G的数据，那是灾难性的。
这里的说的是主动方法的缺点，解决这个问题当然有很多的方法，通过通知的方式就是其中有效的一种。
zookeeper关于数据的创建、更新、删除都能发送通知给客户端。

## watch 监视点
例如我们的主要主节点创建了一个临时的节点来定义一个锁，而备份主节点可以注册一个监视点来监视这个主节点锁是否存在，如果主节点崩溃，主节点锁自动被删除，并通知所有的备份主节点。一旦备份主节点收到通知，它们就可以开始进行新的主节点选举了。

#### 单次触发器
watch的事件具有最多只触发一次的特性，例如，当节点/z被删除，客户端通过执行exists操作(下面会介绍)并设置监视点标识位，等待直到收到通知。但是接受到通知以后改事件将被删除且不会被设置了。
所以这里有一个单次触发会丢失的问题(如果你使用zclient组件不需要考虑这个问题，因为组件帮你实现了)，如果没有使用组件，你可以通过读取zookeeper的状态信息来获得。假设一个从节点接收到一个新任务分配给它的通知。为了接收新任务，从节点读取任务列表，如果在通知接收后，又给这个从节点分配了更多的任务，在通过getChildren调用获取任务列表时会返回所有的任务。同时调用getChildren时也可以设置新的监视点，从而保证从节点不会丢失任务。
#### 使用监视点代替显式缓存管理
从应用的角度，客户端每次都需要是通过访问zookeeper来获取节点的数据、或者节点的子节点列表以及其它的zookeeper状态，但是__这种方式并不可取__。
更高效的做法是客户端在本地缓存数据，然后让使用watch机制，在监听到数据变化的时候再去更新缓存的数据。

#### watch如何保证顺序性
write的顺序：
之前的章节讲过，zookeeper可以使用zxid(版本特性)来保证数据的强一致性，由于网路延迟等原因造成延迟的提交，如果这时候发生另一次的修改，且这次修改的zxid较于它更新，则晚来的修改将被拒绝。所以写的顺序不用担心。
read的顺序：
如果有两次更新(u和u')的时间间隔极小，客户端将仅能感知u‘的变化，比如，一个节点/config，应用包含的数据/config/m{n},如果应用同时更新了m1,m2，但是用户却只收到m2的更新，从而忽略了m1的变化。这里一个解决方案是每次更新的时候创建一个共享锁/config/lock,除了主节点(创建者)以外，其它的客户端监视这个/config/lock节点，一旦被删除，从节点必须更新配置节点。

#### 羊群效应
针对于拥有众多节点的应用，在锁的场景中，想象我们有1000个节点监听了某个锁节点，锁节点被删除的时候，zookeeper将需要给这1000个节点发送通知，从而带来一个尖峰的通知，可能给系统带来问题。之前在infoq的一个讨论就有人提出了这个问题。他的问题还比较复杂，我们的场景是为了解决锁竞争的问题，达到的目的是一次仅有一个节点能拿到锁，所以我们可以简单地这样设计.
客户端创建/lock/lock-的有序节点，假定我们的列表已经按需要从小到大排序，默认最小的节点优先拿到锁，然后次小的节点监听拥有锁的节点，依次下去，这样既能解决锁的问题，又达到削峰的目的。