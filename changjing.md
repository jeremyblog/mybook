#zookeeper入门篇
## zookeeper和分布式编程
失控是一本逼格很高的书籍，超越几代人提出了分布式的概念，20年后的今天，称得上是耳熟能详了吧。
> 分布式定义： 分布式系统是同时跨越多个物理主机，多个独立组件所组成的系统。

__关键字为多主机，独立部署。__
简单地如编写的REST服务，可能背后依赖一个单独的数据库或者缓存系统，但是其对外发布的服务，一般可以通过通过复制的方式同时部署在多个物理机上，以提供程序并行运行的能力，而不会对程序带来任何不良的影响。
当然常见的分布式系统远远比这复杂，比如需要协作的分布式系统，一个大任务被拆分为A、B、C、D等子任务，然后分别由4个独立的子系统处理，子任务还需要等待别扥任务都完成，甚至可能还需要额外的处理才能完成工作。
为了相互配合，所以进程间需要通信，目前的通信由两种选择：
__直接通过网络进行信息交换，或读写某些共享存储__
zookeeper就是后者的佼佼者，不过前者也有其好处
>关于CAP理论
>就是一致性、可用性、分区容灾性，只能3选2。这个理论在过去一直被证明是正确的，现在虽有争论，但是用来说明zookeeper还是合适的。
>zookeeper是集运共享存储来实现信息交换的，需要协作的分布式系统都会用到锁，常见的比如JVM中乐观锁、排它锁什么的。可惜跨进程的分布式系统无法满足，但是锁的要点是一致性，所以支持强一致性zookeeper可以很好的满足了多JVM分布式锁的需求。而可用性是所有系统的非功能性要求，理由很简单，没有客户端愿意相信一个随后宕机的系统。
>3去1,1为分区容灾性，zookeeper直接不考虑这一点，这点似乎和可用性是相悖的，因为跨机房、跨区域部署是现在平台保证可用性的重要手段，而zookeeper偏偏选择不考虑这一点，而是交给用户自己去实现。

## zookeeper应用场景
#### 一、配置管理和数据分发
前面说了，zookeeper是通过读写共享存储来实现进程间协作的，其天生就能保证多JVM间的数据操作一致性，所以在多进程间的管理配置是其与生俱来的能力。另外通过watcher接口，zookeeper可以提供用户监控数据变化的能力，相比原有的主动去查询，数据分发的场景也是非常强大的。例如用户需要发布或者修改了某些服务，通过zookeeper就能轻松地通知众多的用户。

#### 二、 集群机器监控
zookeeper可以创建一些临时性的节点，在机器掉线或者主动下线的时候节点会被删除，这个动作也可以通过watcher来让客户端感知。

#### 三、Master选举
在分布式系统中，有些业务仅能由一个节点来实现，其他的节点可以共享这个结果，这样可以大大减少重复计算，于是需要进行master选举。
这用到的是zookeeper的有序临时节点的特性，每次我们都讲序号最小的那个节点选举为master。

#### 四、分布式锁
__排它锁__  创建一个临时的节点，设置节点的数据为自己的IP，每次读取节点数据时通过判断IP是否为自己来判断是否取得了锁，如果没有则继续监听节点的变化以再次获取锁。
__共享锁__
获取读锁过程：
1. 在/lock下创建有序节点read-.
2. 获取/lock下的子节点
3. 如果没有以write-开头且比自己小的节点(无论write或者read-)，则获得了锁
4. 否则监控这个以wirte-开头并且比自己小的节点，直到这个节点被删除,返回2
5获取写锁过程:
1. 在/lock下创建有序节点write-
2. 获取/lock下的子节点
3. 如果没有比自己小的节点，则获得了写锁。
4. 否则监控这个比自己小的节点，直到这个节点被删除了，返回2

#### 五、负载均衡
这个和数据分发类型，不过nginx等工具比它做得更好，所以似乎没有太必要单纯为了实现负载均衡来实现它。
